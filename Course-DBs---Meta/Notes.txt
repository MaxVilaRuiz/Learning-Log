General Information:
- Relational Databases are organized systematically by table / entities (for organized data).
- No sequel databases (NoSQL) can store data in a variety of different formats (e.g. document dbs, key-value dbs, graphs dbs). 
- Big Data can manage a combination of structured, semistructured & unstructured data. Is more powerful & complex that traditional data when solving problems (improves decision making)


SQL subsets:
    * Data definition language (DDL):
        - DDL Create cmd: Used to create storage objects in a db.
        - DDL Alter cmd: Modify the structure of a table object in a db.
        - DDL Drop cmd: Remove an existing object from a db.
    * Data manipulation language (DML):
        - DML Insert cmd: Insert records of data into a db table.
        - DML Update cmd: Edit data that already exists in a db table.
        - DML Delete cmd: Delete data that already exists.
    * Data query language (DQL): Defines a select cmd to be able to retrieve data.
    * Data control language (DCL): Control access to the db.


Constraints (db rules):
* Key Constraints: specifies that there should be a column, or columns, in a table that can be used to fetch data for any row.
* Domain Constraints: refer to the rules defined for the values that can be stored for a certain column.
* Referential Integrity Constraint: When a table is related to another table via a foreign key column, then the referenced column value must exist in the other table.
* NOT NULL SQL Constraint: Ensures data fields never left blank.
* DEFAULT Constraint: Sets a default value for a column if no value is specified. 


Types of keys:
- Candidate Key Attribute: any attribute that contains a unique value in each row of the table.
- Composite Key Attribute: a key composed of two or more attributes to form a unique value in each new row.
- Primary Key: a selected candidate key (e.g. PRIMARY KEY (column_name1)).
- Alternate Key: a candidate key no selected as the primary key.
- Foreign Key: an attribute that references a unique key in another table (e.g. FOREIGN KEY (column_name1) REFERENCES table_name(column_name2)).


Basic Syntax:
- Create a DB: 
    CREATE DATABASE database_name;
    CREATE DATABASE database_name (column_name1 datatype(size), column_name2 datatype(size));

- To delete a db or a table inside a db:
    DROP TABLE table_name;

- Create a table: CREATE TABLE table_name;

- Add data to a table: 
    INSERT INTO table_name (column_one, columne_two...) VALUES (value1, value2...)

- Add data of a columne of a table into another table:
    INSERT INTO target_tbl (column_name) 
    SELECT column_name 
    FROM source_tbl;

- Update data in a table:
    UPDATE table_name
    SET column_name (e.g. column1) = 'value'
    WHERE ID (column_name) = row_id;

- Delete data from a table:
    DELETE FROM table_name
    WHERE ID (column_name) = row_id;

- Query data within a table:
    SELECT column_name1, column_name2,
    FROM table_name
    WHERE ID (column_name) = 'row_id';

- To add a column into a table:
    ALTER TABLE table_name ADD column_name datatype(size);

- To add a primary key to a table: 
    ALTER TABLE table_name ADD primary key (column_name);

- To modify an existing column: 
    ALTER TABLE table_name MODIFY COLUMN column_name <datatype> NOT NULL...;

- To delete an existing column from a table:
    ALTER TABLE table_name DROP COLUMN column_name;

- To rename an existing column from a table:
    ALTER TABLE table_name CHANGE from_column_name to_column_name datatype;

- To change a table name:
    ALTER TABLE table_name RENAME new_table_name;

- To empty a table but not delete the table itself:
    TRUNCATE TABLE table_name;
    DELETE FROM table_name; 

- Use '--' to comment.

- To select data from a table ('*' into the column_name to select all columns):
    SELECT column_name1, column_name2 FROM table_name; 

- To do operations, write 'SELECT' before the operation (e.g. SELECT column_name1 + column_name2 FROM table_name).

- ORDER BY clause:
    SELECT column_name1, column_name2, column_name3...
    FROM table_name
    ORDER BY column_name4 ASC (for ascending order), column_name5 DESC (for descending order), column_name6;

- To select without duplicates:
    SELECT DISTINCT column_name
    FROM table_name;

- To count the multiple distinct values:    
    SELECT COUNT(DISTINCT column_name)
    FROM table_name;

- To review the table structure:
    SHOW COLUMNS FROM table;


Operators / Commands:
    WHERE clause: to determinate how data is filtered in a table 
        (e.g. SELECT <cols> FROM <table> WHERE <condition1> AND <condition2> OR (<condition3> NOT(<condition4>));).
    BETWEEN: Filter records within a range 
        (e.g. SELECT * FROM table_name WHERE column_name BETWEEN <value1> AND <value2>;). 
    LIKE: Specify a pattern within the search criteria 
        (e.g. SELECT * FROM table_name WHERE column_name LIKE 'hell_%' 
        (% = any other value, _ = a single character that can be any)).
    IN: Specify multiple possible values for a column 
        (e.g. SELECT * FROM table_name WHERE column_name IN('value1', 'value2'...)).
    UNION: Combines results sets from multiple statements in the same query. 
           The column number in both tables must be the same. Similar datatypes in related columns. 
           All related columns must have same order.
        (e.g. SELECT column1, column2 FROM table1 UNION (ALL) SELECT column1, column2 FROM table2;) -> 'ALL' to ensure that all values remain, even the duplicates.
    GROUP BY: Groups rows in a table based on given columns, into summary rows, or subgroups
        (e.g. SELECT column1, column2 (, AggregateFunction(column_x)) FROM  table1 (WHERE ...) GROUP BY column1, column2;).
    HAVING: Specifies a filter condition for groups of rows or aggregates 
        (e.g. SELECT column(s) FROM table WHERE filter_condition GROUP BY group_by_column_or_expression HAVING group_filter_condition;).
    REPLACE: Insert or update data in a table by deleting and replacing existing records (by its primary or UNIQUE key)
        (e.g. REPLACE INTO table (column1, column2...) VALUES (column1_value, column2_value...); 
        REPLACE INTO table (column1, column2...) SET column_name = new_value;).
    ANY operator: return data for any values that meet the specified contidition.
    ALL operator: return data for all values 
        (e.g. SELECT column_name(s) FROM table_name WHERE expression operator > ALL (SELECT column_name FROM table_name WHERE column DATA TYPE (value1, value2, value3));).
    SOME operator: returns data for one or more matching values.
    EXISTS operator: true if it does return at least one row of results
        (e.g. SELECT column_name(s) FROM table_name WHERE (NOT) EXISTS (SELECT column_name FROM table_name WHERE condition);).
    NOT EXISTS: true if it doesn't return any row of results. 


Datatypes:
- String: CHAR (defined length), VARCHAR (variable length), TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT
- Numeric: INT, TYNYINT (small intengers - max: 255), BIGINT (big intengers - max: 4B), FLOAT, REAL
- Date and time: DATE, TIME, DATETIME
- Binary (for images...): BINARY, VARBINARY
- Miscellaneous: Character Large Object (CLOB), Binary Large Object (BLOB)


Schemas:
- Logical Database Schema: components within a schema, illustrating relationships between entity types (Entity Relationship Modeling)
- Physical Schema: how the physical structure of a database is stored on a disk.
- Tables Relationships: one-to-one, many-to-one, many-to-many.
- Entity Relationship Diagrams (ER-Diagrams): rectangules = entity, diamonds = relationship.


Attributes:
- Simple attributes: cannot be splited in multiple attributes (e.g. Grade).
- Composite attributes: can be splited in multiple attributes (e.g. Name -> First Name, Second Name).
- Single Value attributes: can only store one value (e.g. Age). 
- Multi-valued attributes: can store multiple values on the field (e.g. Emails)
- Derived attributes: the value of an attribute is derived from another (e.g. Age).
- Key attributes: unique value that is useful to identify the record.


Normalization:
-> Process for structuring tables that minimizes challenges facing db systems. Optimizes the db design by creating a single purpose for each table.
- Normalization Challenges: 
    * Insert anomaly: insertion of one record leads to the insertion of several more required data sets.
    * Update anomaly: updating a record in a table column requires further updates in other columns.
    * Deletion anomaly: deletion of one record leads to the deletion of several more required data sets.
- First Normal Form (1NF): enforces data atomicity (ensuring that there is only one single instance value per column field) & eliminates unnecessary repeating groups of data in database tables.
- Second Normal Form (2NF): ensure you have a proper structure, reduce duplication, allow for accurate data analysis & retrieval.
    * Functional Dependency: relationship between two attributes in a table.
    * Partial Dependency: a table with a composite primary key.
- Third Normal Form (3NF): 
    * Transitive Dependency: a non-key attribute cannot be functionally dependent on another non-key attribute.


Aliases:
-> Provide temporary names within the database for ease-of-use (AS).
- Renaming tables: 
    SELECT column1_name AS column1_alias, column2, column3 AS column3_alias FROM table_name;
- Concat functions:
    SELECT CONCAT (column1, " ", column2) AS 'new_column_name' FROM table_name;
- Multiple tables:
    SELECT x.column1, x.column2, y.column1, y.column2 FROM table1_name AS x, table2_name AS y WHERE x.column2 < 12...;


Joins:
-> Links records of data between one or multiple tables based on a common column between them (e.g. you want to retrieve data from a db, but these data exists in more than one table, so you use SQL JOINS clause to query the required data from multiple tables).
- INNER JOIN: 
    -> Returns data that have matching values in the joined tables 
    (e.g. SELECT Customers.FullName, Bookings.BookingID FROM Customers INNER JOIN Bookings ON Customers.CustomerID = Bookings.CustomerID;).
- LEFT JOIN: 
    -> Extracts all records of data from left table and matching records from right table 
    (e.g. SELECT Customers.FullName, Bookings.BookingID FROM Customers LEFT JOIN Bookings ON Customers.CustomerID =  Bookings.CustomerID;).
- RIGHT JOIN:
    -> Extracts all records of data from right table and matching records from left table 
    (e.g. SELECT Customers.FullName, Bookings.BookingID FROM Customers RIGHT JOIN Bookings ON Customers.CustomerID = Bookings.CustomerID;).
- SELF JOIN:
    -> When you need to join a table with itself to get specific information existing in the same table (you may choose the INNER, LEFT or RIGHT JOIN).


Views:
-> Virtual tables used for accessing and manipulating data with MySQL.
-> Useful to: 
    * Create a subset: focus on a subset of a table's data.
    * Combine data: combine data from multiple tables into one.
-> Creating a virtual table:
    1. Create the virtual table.
    2. Select the table's columns.
    3. Specify a table to extract data from.
    4. Set the conditions.
    5. Set data order and filtering rule.
-> Syntax:
    * One table:
        CREATE VIEW view_name AS 
        SELECT table1.column1, table1.column2 
        FROM table_name 
        WHERE condition;
    * Multiple tables: 
        CREATE VIEW view_name AS 
        SELECT table1.column1, table2.column1 
        FROM table1_name INNER JOIN table2_name 
        ON table1.column1 = table2.column1 
        WHERE condition;
-> To display a view:
    SELECT * FROM view_name;
-> Rename a view:
    RENAME TABLE old_name TO new_name;
-> Delete a view:
    DROP VIEW view_name;


Functions:
-> 2 types: Aggregate funcs (perform tasks on a set of values) & Math funcs (perform basic maths tasks on data).
- Types of functions:
    * Numeric functions:
        - CEIL(): returns the smallest integer value, which is not less than the passed value.
            SELECT CEIL(15.20); // Output = 16
        - FLOOR(): opposite of CEIL func.
            SELECT FLOOR(VALUE);
    * String functions
        - CONCAT(): to add several string together.
            SELECT CONCAT("string1", "string2")
            FROM table_name
            WHERE condition;
        - SUBSTR(): extracts a segment of a string.
            SELECT SUBSTR("string", start index, length)
            FROM table_name
            WHERE condition;
        - UCASE(): convert the string to upper case.
            SELECT UCASE(column_name)
            FROM table_name;
        - PCASE(): convert the string to lower case.
            SELECT PCASE(column_name)
            FROM table_name;
        - FORMAT(): function formats the number passed into a format like '#,###,###.##'.
            SELECT FORMAT(number_to_be_formatted, number_of_decimal_places);
        - LENGTH()
        - REPLACE()
    * Date functions
        - CURRENT_DATE():
            SELECT CURRENT_DATE();
        - CURRENT_TIME():
            SELECT CURRENT_TIME();
        - DATE_FORMAT(): 1st param = date to be formatted
                         2nd param = the format to use, can be a combination of multiple formats (look the manual)
            DATE_FORMAT('YYY-MM-DD', "format")
        - DATEDIFF():
            SELECT DATEDIFF("date1", "date2");
        - ADDDATE(): to perform arithmetic with dates.
            SELECT ADDDATE(date, INTERVAL expr unit);
            (INTERVAL = keyword, expr = represents a quantity, unit represents the unit for interpreting the quantity (e.g. DAY))
    * Comparison functions
        - GREATEST():
            SELECT column1
            GREATEST (column2, column3, column4) AS highest,
            FROM table_name;
        - LEAST():
            SELECT column1
            LEAST (column2, column3, column4) AS lowest,
            FROM table_name;
        - ISNULL():
            SELECT ISNULL(column_name)
            FROM table_name;
            ---
            SELECT *
            FROM table_name
            WHERE ISNULL(column_name)
        - COALESCE(): takes several arguments and returns the first non-NULL argument.
            SELECT COALESCE(value1, value2...);
    * Control flow functions
        -> Evaluate conditions & determinate the execution path of a query
        - CASE(): Runs through a set of conditions contained within a CASE block & returns a value when the first condition is met.
            CASE 
                WHEN condition1 THEN result1
                WHEN condition2 THEN result2
                WHEN conditionN THEN resultN
                ELSE result1
            END
        - IFNULLL()
            SELECT IFNULL(evaluated_expression, alternative_value);
        - NULLIF(): given two values or expressions, returns null if both values are equal.
            SELECT NULLIF(expression1, expression2);
            
- Aggregate functions:
    * SUM()
    * AVERAGE() / AVG()
    * MAX()
    * MIN()
    * COUNT()

- Math functions:
    * ROUND(): 1st param = column_name || numeric value 
        SELECT column_name, ROUND(column_name, decimal places) 
        FROM table;
    * MOD(): 1st param = table column || numeric value
        SELECT column_name, MOD(column/value, divide by value)
        FROM table;

- Stored procedures:
    -> Reusable block of code invoked on command.
    * Basic syntax:
        CREATE PROCEDURE ProcedureName(parameter_value INT)
        SELECT column_name
        FROM table_name
        WHERE value = parameter_value;
    * Invoke:
        CALL ProcedureName();
    * Delete a procedure:
        DROP PROCEDURE ProcedureName;
    * Modify a procedure: you have to drop the procedure & create a new one.