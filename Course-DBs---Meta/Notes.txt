General Information:
- Relational Databases are organized systematically by table / entities (for organized data).
- No sequel databases (NoSQL) can store data in a variety of different formats (e.g. document dbs, key-value dbs, graphs dbs). 
- Big Data can manage a combination of structured, semistructured & unstructured data. Is more powerful & complex that traditional data when solving problems (improves decision making)


SQL subsets:
    * Data definition language (DDL):
        - DDL Create cmd: Used to create storage objects in a db.
        - DDL Alter cmd: Modify the structure of a table object in a db.
        - DDL Drop cmd: Remove an existing object from a db.
    * Data manipulation language (DML):
        - DML Insert cmd: Insert records of data into a db table.
        - DML Update cmd: Edit data that already exists in a db table.
        - DML Delete cmd: Delete data that already exists.
    * Data query language (DQL): Defines a select cmd to be able to retrieve data.
    * Data control language (DCL): Control access to the db.


Constraints (db rules):
* Key Constraints: specifies that there should be a column, or columns, in a table that can be used to fetch data for any row.
* Domain Constraints: refer to the rules defined for the values that can be stored for a certain column.
* Referential Integrity Constraint: When a table is related to another table via a foreign key column, then the referenced column value must exist in the other table.
* NOT NULL SQL Constraint: Ensures data fields never left blank.
* DEFAULT Constraint: Sets a default value for a column if no value is specified. 


Types of keys:
- Candidate Key Attribute: any attribute that contains a unique value in each row of the table.
- Composite Key Attribute: a key composed of two or more attributes to form a unique value in each new row.
- Primary Key: a selected candidate key (e.g. PRIMARY KEY (column_name1)).
- Alternate Key: a candidate key no selected as the primary key.
- Foreign Key: an attribute that references a unique key in another table (e.g. FOREIGN KEY (column_name1) REFERENCES table_name(column_name2)).


Basic Syntax:
- Create a DB: 
    CREATE DATABASE database_name;
    CREATE DATABASE database_name (column_name1 datatype(size), column_name2 datatype(size));

- To delete a db or a table inside a db:
    DROP TABLE table_name;

- Create a table: CREATE TABLE table_name;

- Add data to a table: 
    INSERT INTO table_name (column_one, columne_two...) VALUES (value1, value2...)

- Add data of a columne of a table into another table:
    INSERT INTO target_tbl (column_name) 
    SELECT column_name 
    FROM source_tbl;

- Update data in a table:
    UPDATE table_name
    SET column_name (e.g. column1) = 'value'
    WHERE ID (column_name) = row_id;

- Delete data from a table:
    DELETE FROM table_name
    WHERE ID (column_name) = row_id;

- Query data within a table:
    SELECT column_name1, column_name2,
    FROM table_name
    WHERE ID (column_name) = 'row_id';

- To add a column into a table:
    ALTER TABLE table_name ADD column_name datatype(size);

- To add a primary key to a table: 
    ALTER TABLE table_name ADD primary key (column_name);

- To modify an existing column: 
    ALTER TABLE table_name MODIFY COLUMN column_name <datatype> NOT NULL...;

- To delete an existing column from a table:
    ALTER TABLE table_name DROP COLUMN column_name;

- To rename an existing column from a table:
    ALTER TABLE table_name CHANGE from_column_name to_column_name datatype;

- To change a table name:
    ALTER TABLE table_name RENAME new_table_name;

- To empty a table but not delete the table itself:
    TRUNCATE TABLE table_name;
    DELETE FROM table_name; 

- Use '--' to comment.

- To select data from a table ('*' into the column_name to select all columns):
    SELECT column_name1, column_name2 FROM table_name; 

- To do operations, write 'SELECT' before the operation (e.g. SELECT column_name1 + column_name2 FROM table_name).

- ORDER BY clause:
    SELECT column_name1, column_name2, column_name3...
    FROM table_name
    ORDER BY column_name4 ASC (for ascending order), column_name5 DESC (for descending order), column_name6;

- To select without duplicates:
    SELECT DISTINCT column_name
    FROM table_name;

- To count the multiple distinct values:    
    SELECT COUNT(DISTINCT column_name)
    FROM table_name;

- To review the table structure:
    SHOW COLUMNS FROM table;


Operators / Commands:
    WHERE clause: to determinate how data is filtered in a table 
        (e.g. SELECT <cols> FROM <table> WHERE <condition1> AND <condition2> OR (<condition3> NOT(<condition4>));).
    BETWEEN: Filter records within a range 
        (e.g. SELECT * FROM table_name WHERE column_name BETWEEN <value1> AND <value2>;). 
    LIKE: Specify a pattern within the search criteria 
        (e.g. SELECT * FROM table_name WHERE column_name LIKE 'hell_%' 
        (% = any other value, _ = a single character that can be any)).
    IN: Specify multiple possible values for a column 
        (e.g. SELECT * FROM table_name WHERE column_name IN('value1', 'value2'...)).
    UNION: Combines results sets from multiple statements in the same query. 
           The column number in both tables must be the same. Similar datatypes in related columns. 
           All related columns must have same order.
        (e.g. SELECT column1, column2 FROM table1 UNION (ALL) SELECT column1, column2 FROM table2;) -> 'ALL' to ensure that all values remain, even the duplicates.
    GROUP BY: Groups rows in a table based on given columns, into summary rows, or subgroups
        (e.g. SELECT column1, column2 (, AggregateFunction(column_x)) FROM  table1 (WHERE ...) GROUP BY column1, column2;).
    HAVING: Specifies a filter condition for groups of rows or aggregates 
        (e.g. SELECT column(s) FROM table WHERE filter_condition GROUP BY group_by_column_or_expression HAVING group_filter_condition;).
    REPLACE: Insert or update data in a table by deleting and replacing existing records (by its primary or UNIQUE key)
        (e.g. REPLACE INTO table (column1, column2...) VALUES (column1_value, column2_value...); 
        REPLACE INTO table (column1, column2...) SET column_name = new_value;).
    ANY operator: return data for any values that meet the specified contidition.
    ALL operator: return data for all values 
        (e.g. SELECT column_name(s) FROM table_name WHERE expression operator > ALL (SELECT column_name FROM table_name WHERE column DATA TYPE (value1, value2, value3));).
    SOME operator: returns data for one or more matching values.
    EXISTS operator: true if it does return at least one row of results
        (e.g. SELECT column_name(s) FROM table_name WHERE (NOT) EXISTS (SELECT column_name FROM table_name WHERE condition);).
    NOT EXISTS: true if it doesn't return any row of results. 


Datatypes:
- String: CHAR (defined length), VARCHAR (variable length), TINYTEXT, TEXT, MEDIUMTEXT, LONGTEXT
- Numeric: INT, TYNYINT (small intengers - max: 255), BIGINT (big intengers - max: 4B), FLOAT, REAL
- Date and time: DATE, TIME, DATETIME
- Binary (for images...): BINARY, VARBINARY
- Miscellaneous: Character Large Object (CLOB), Binary Large Object (BLOB)


Schemas:
- Logical Database Schema: components within a schema, illustrating relationships between entity types (Entity Relationship Modeling)
- Physical Schema: how the physical structure of a database is stored on a disk.
- Tables Relationships: one-to-one, many-to-one, many-to-many.
- Entity Relationship Diagrams (ER-Diagrams): rectangules = entity, diamonds = relationship.


Attributes:
- Simple attributes: cannot be splited in multiple attributes (e.g. Grade).
- Composite attributes: can be splited in multiple attributes (e.g. Name -> First Name, Second Name).
- Single Value attributes: can only store one value (e.g. Age). 
- Multi-valued attributes: can store multiple values on the field (e.g. Emails)
- Derived attributes: the value of an attribute is derived from another (e.g. Age).
- Key attributes: unique value that is useful to identify the record.


Normalization:
-> Process for structuring tables that minimizes challenges facing db systems. Optimizes the db design by creating a single purpose for each table.
- Normalization Challenges: 
    * Insert anomaly: insertion of one record leads to the insertion of several more required data sets.
    * Update anomaly: updating a record in a table column requires further updates in other columns.
    * Deletion anomaly: deletion of one record leads to the deletion of several more required data sets.
- First Normal Form (1NF): enforces data atomicity (ensuring that there is only one single instance value per column field) & eliminates unnecessary repeating groups of data in database tables.
- Second Normal Form (2NF): ensure you have a proper structure, reduce duplication, allow for accurate data analysis & retrieval.
    * Functional Dependency: relationship between two attributes in a table.
    * Partial Dependency: a table with a composite primary key.
- Third Normal Form (3NF): 
    * Transitive Dependency: a non-key attribute cannot be functionally dependent on another non-key attribute.


Aliases:
-> Provide temporary names within the database for ease-of-use (AS).
- Renaming tables: 
    SELECT column1_name AS column1_alias, column2, column3 AS column3_alias FROM table_name;
- Concat functions:
    SELECT CONCAT (column1, " ", column2) AS 'new_column_name' FROM table_name;
- Multiple tables:
    SELECT x.column1, x.column2, y.column1, y.column2 FROM table1_name AS x, table2_name AS y WHERE x.column2 < 12...;


Joins:
-> Links records of data between one or multiple tables based on a common column between them (e.g. you want to retrieve data from a db, but these data exists in more than one table, so you use SQL JOINS clause to query the required data from multiple tables).
- INNER JOIN: 
    -> Returns data that have matching values in the joined tables 
    (e.g. SELECT Customers.FullName, Bookings.BookingID FROM Customers INNER JOIN Bookings ON Customers.CustomerID = Bookings.CustomerID;).
- LEFT JOIN: 
    -> Extracts all records of data from left table and matching records from right table 
    (e.g. SELECT Customers.FullName, Bookings.BookingID FROM Customers LEFT JOIN Bookings ON Customers.CustomerID =  Bookings.CustomerID;).
- RIGHT JOIN:
    -> Extracts all records of data from right table and matching records from left table 
    (e.g. SELECT Customers.FullName, Bookings.BookingID FROM Customers RIGHT JOIN Bookings ON Customers.CustomerID = Bookings.CustomerID;).
- SELF JOIN:
    -> When you need to join a table with itself to get specific information existing in the same table (you may choose the INNER, LEFT or RIGHT JOIN).


Views:
-> Virtual tables used for accessing and manipulating data with MySQL.
-> Useful to: 
    * Create a subset: focus on a subset of a table's data.
    * Combine data: combine data from multiple tables into one.
-> Creating a virtual table:
    1. Create the virtual table.
    2. Select the table's columns.
    3. Specify a table to extract data from.
    4. Set the conditions.
    5. Set data order and filtering rule.
-> Syntax:
    * One table:
        CREATE VIEW view_name AS 
        SELECT table1.column1, table1.column2 
        FROM table_name 
        WHERE condition;
    * Multiple tables: 
        CREATE VIEW view_name AS 
        SELECT table1.column1, table2.column1 
        FROM table1_name INNER JOIN table2_name 
        ON table1.column1 = table2.column1 
        WHERE condition;
-> To display a view:
    SELECT * FROM view_name;
-> Rename a view:
    RENAME TABLE old_name TO new_name;
-> Delete a view:
    DROP VIEW view_name;


Functions:
-> 2 types: Aggregate funcs (perform tasks on a set of values) & Math funcs (perform basic maths tasks on data).
-> Must return a single value, takes IN params only, must specify the data type of the return value & are invoked using the SELECT statement.
- Types of functions:
    * Numeric functions:
        - CEIL(): returns the smallest integer value, which is not less than the passed value.
            SELECT CEIL(15.20); // Output = 16
        - FLOOR(): opposite of CEIL func.
            SELECT FLOOR(VALUE);
    * String functions
        - CONCAT(): to add several string together.
            SELECT CONCAT("string1", "string2")
            FROM table_name
            WHERE condition;
        - SUBSTR(): extracts a segment of a string.
            SELECT SUBSTR("string", start index, length)
            FROM table_name
            WHERE condition;
        - UCASE(): convert the string to upper case.
            SELECT UCASE(column_name)
            FROM table_name;
        - PCASE(): convert the string to lower case.
            SELECT PCASE(column_name)
            FROM table_name;
        - FORMAT(): function formats the number passed into a format like '#,###,###.##'.
            SELECT FORMAT(number_to_be_formatted, number_of_decimal_places);
        - LENGTH()
        - REPLACE()
    * Date functions
        - CURRENT_DATE():
            SELECT CURRENT_DATE();
        - CURRENT_TIME():
            SELECT CURRENT_TIME();
        - DATE_FORMAT(): 1st param = date to be formatted
                         2nd param = the format to use, can be a combination of multiple formats (look the manual)
            DATE_FORMAT('YYY-MM-DD', "format")
        - DATEDIFF():
            SELECT DATEDIFF("date1", "date2");
        - ADDDATE(): to perform arithmetic with dates.
            SELECT ADDDATE(date, INTERVAL expr unit);
            (INTERVAL = keyword, expr = represents a quantity, unit represents the unit for interpreting the quantity (e.g. DAY))
    * Comparison functions
        - GREATEST():
            SELECT column1
            GREATEST (column2, column3, column4) AS highest,
            FROM table_name;
        - LEAST():
            SELECT column1
            LEAST (column2, column3, column4) AS lowest,
            FROM table_name;
        - ISNULL():
            SELECT ISNULL(column_name)
            FROM table_name;
            ---
            SELECT *
            FROM table_name
            WHERE ISNULL(column_name)
        - COALESCE(): takes several arguments and returns the first non-NULL argument.
            SELECT COALESCE(value1, value2...);
    * Control flow functions
        -> Evaluate conditions & determinate the execution path of a query
        - CASE(): Runs through a set of conditions contained within a CASE block & returns a value when the first condition is met.
            CASE 
                WHEN condition1 THEN result1
                WHEN condition2 THEN result2
                WHEN conditionN THEN resultN
                ELSE result1
            END
        - IFNULLL()
            SELECT IFNULL(evaluated_expression, alternative_value);
        - NULLIF(): given two values or expressions, returns null if both values are equal.
            SELECT NULLIF(expression1, expression2);
            
- Aggregate functions:
    * SUM()
    * AVERAGE() / AVG()
    * MAX()
    * MIN()
    * COUNT()

- Math functions:
    * ROUND(): 1st param = column_name || numeric value 
        SELECT column_name, ROUND(column_name, decimal places) 
        FROM table;
    * MOD(): 1st param = table column || numeric value
        SELECT column_name, MOD(column/value, divide by value)
        FROM table;

- Stored procedures:
    -> Reusable block of code invoked on command that can accept both input & output parameters (IN, OUT, INOUT). 
    -> Useful to manipulating, processing & modifying data.
    -> Can return a single value, multiple values or no value.
    * Basic syntax:
        CREATE PROCEDURE ProcedureName(parameter_value INT)
        SELECT column_name
        FROM table_name
        WHERE value = parameter_value;
    * Invoke:
        CALL ProcedureName();
    * Delete a procedure:
        DROP PROCEDURE ProcedureName;
    * Modify a procedure: you have to drop the procedure & create a new one.

- User-defined functions:
    -> Created to perform operations that can't be completed with build-in functions.
    -> Use 'DELIMITER //' before writing the func & '//', 'DELIMITER ;' after the func to compile the whole func as a single compound statement using begin end keywords.
    * Basic syntax:
        CREATE FUNCTION function_name()
        RETURNS datatype DETERMINISTIC // 'DETERMINISTIC' = Always returns the same output for the same input params
        RETURN
    * Delete the func:
        DROP FUNCTION function_name;

- Parameters:
    * IN: Default param, used to pass a param to a stored procedure.
        e.g. CREATE PROCEDURE procedure_name(IN logic(value1, value2)) SELECT logic;
    * OUT: To pass a value to a variable outside of the procedure.
        e.g.    CREATE PROCEDURE GetLowestCost (OUT LowestCost DECIMAL(6,2))
                SELECT MIN(Cost) INTO LowestCost FROM Orders;
                CALL GetLowestCost(@order_lowest_cost);
    * INOUT: To pass an argument to the procedure & then pass the new value back to the outside.
        e.g.    CREATE PROCEDURE SquareAnumber(INOUT aNumber INT)
                BEGIN
                    SET aNumber = aNumber * aNumber;
                END
                SET @x_number = 5;
                CALL SquareAnumber(@x_number);


Variables:
-> You can create variables inside or outside of a stored procedure or a SELECT statements.
* Syntax: 
    @variable_name = value;

    - Stored Procedures:
    SET @variable_name = value; // Assignation
    DECLARE variable_name DATATYPE DEFAULT VALUE; // Declaration

    - SELECT statements:
    SELECT @variable_name := value; // Assignation
    SELECT @variable_name; // Access to the value
    SELECT function() INTO variable_name FROM table_name;


Triggers:
-> Set of actions available in the form of a stored program invoked when a event occurs (insert, update & detele data in a table).
-> Useful for maintaining audit trails (keeping a log of records) & are a alternative to constraints (maintain data integrity).
* Create syntax:
    CREATE TRIGGER trigger_name
    MODIFIER TYPE
    ON table_name FOR EACH ROW
    BEGIN 
        statement1
        statement2
    END
* Deletes syntax:
    DROP TRIGGER IF EXISTS schema_name.trigger_name
* Types:
    - Row-level: Invoked for each row inserted, updated or deleted in a table.
    - Statement-level: Invoked for each statement & occurs just once, no matter how many rows are inserted.

    - Modifiers: BEFORE & AFTER (when a trigger can be invoked), NEW & OLD (depends on BEFORE & AFTER mods).
    - Types: INSERT, UPDATE, DELETE.
* Show:
    SHOW TRIGGERS 
    [{FROM | IN} database_name]
    [LIKE 'pattern' | WHERE search_condition]; 


Scheduled events:
-> A task that takes place at a specific time according to a schedule.
-> Each event has a unique Name, contains one or more Statements & can be executed just once or they can be a recurring event.
* Syntax: 
    CREATE EVENT [IF NOT EXISTS] event_name
    ON SCHEDULE <schedule_logic>
    DO 
    Event_body
* Schedule_logic:
    - One-time syntax:
        AT CURRENT_TIMESTAMP [+ INTERVAL]
    - Recurring syntax:
        EVERY interval STARTS timestamp [+INTERVAL] ENDS timestamp [+INTERVAL]
* Delete an event:
    DROP EVENT [IF EXISTS] event_name;


Optimization:
- Retrieving data: 
    * Use target required columns
    * Avoid functions & leading wildcards (e.g. LIKE)
    * Use INNER JOIN & clauses sparingly (e.g. DISTINCT, UNION)
    * Create specific columns to search through the db more efficiently if necessary

- SELECT statement:
    SELECT column1, column2
    FROM table_name;
    // While using only a few columns, intead of:
    SELECT * FROM table_name;

- EXPLAIN: 
    -> Used to see what the execution plan looks like
    * Syntax:
        EXPLAIN SELECT column_name
        FROM table_name
        WHERE value...;
    * Results:
        - Column 1: ID column as a sequential identifier for each SELECT statement.
        - Column 2: Type of SELECT query to be executed.
            * SIMPLE: Simple SELECT query without any subqueries or UNIONs.
            * PRIMARY: The SELECT is in the outermost query in a JOIN.
            * DERIVED: The SELECT is part of a subquery within a FROM clause.    
            * SUBQUERY: The first SELECT in a subquery.
            * DEPENDENT SUBQUERY: The SELECT statements is a subquery dependent on an outer query.    
            * UNCACHEABLE SUBQUERY: Subquery which is not cacheable (there are certain conditions for a query to be cacheable).
            * UNION: The SELECT query is the second or later statement of a UNION.
            * DEPENDENT UNION: The second or later SELECT of a UNION is dependent on an outer query.
            * UNION RESULT: The SELECT is a result of a UNION.
        - Column 3: Displays the name of the table referred.
        - Column 4: Displays the partition in which the data resides (the area of physical storage that's scanned).
        - Column 5:
            * system: The table has only one row or zero rows. This return value typically indicates that the search was performed on a system table.   
            * const: Indicates that the value of the searched column can be treated as a constant (there is one row matching the query).
            * eq_ref: Indicates that the index is clustered and is being used by the operation (either the index is a PRIMARY KEY or UNIQUE INDEX with all key columns defined as NOT NULL).
            * ref: Indicates that the indexed column was accessed using an equality operator. You can see an example of this in the optimized Lucky Shrub query EXPLAIN statement results, as the indexed column FullName is matched or accessed using the = operator in the WHERE clause. 
            * full text: The scan uses the table’s FULLTEXT index. Full-text indexes are created on text-based columns (CHAR , VARCHAR , or TEXT columns).    
            * index: The entire index is scanned to find a match for the query.
            * all: The entire table is scanned to find matching rows. This is the worst scan type and usually indicates the lack of appropriate indexes on the table. 
        - Column 6: Shows the keys that can be used by MySQL to find rows from the table.
        - Column 7: Actual index used by MySQL.
        - Column 8: Indicates the length of the index the Query Optimizer chooses to use.
        - Column 9: Shows which table columns have been compared to the index to perform the search.
        - Column 10: Lists the number of records that were examined to produce the output.
        - Column 11: indicates an approximate percentage of the number of table rows that have been filtered by a specified condition (the higher the percentage is, the better the performance of the query).
        - Column 12: Additional information regarding the query execution plan.
            -> Pay attention if there are values like  Using temporary or Using filesort in this column as they indicate a problematic query.

- Indexes:
    -> Data structure that provides pointers to sorted data.
    -> Use 'idx' followed by the column name when creating a name for an index.

    * Primary / Clustered index: is stored within the table itself.
    * Secondary / Non-Clustered index:
        CREATE INDEX index_name FROM table_name (column_list)

- Transactions:
    -> One or more queries that can be commited permanently to the database.
    -> Statements to manage db transactions:
        * START TRANSACTION: Standard SQL statement to start the transaction process.
        * BEGIN / BEGIN WORK 
        * COMMIT 
        * ROLL BACK 
    + Syntax: 
        * Starting:
            [START TRANSACTION / BEGIN]
            SQL_statement1
            SQL_statement2
            SQL_statement3
        * Commiting: commit transactions changes to the db.
            COMMIT 
        * Cancelling changes: Rollback transaction after commiting.
            ROLLBACK

- Common Table Expressions (CTE):
    -> Optimizing complex database queries by compiling them as simple blocks of code.
    * Syntax for a single CTE:
        WITH common_table_name AS
        (query code)
        SELECT * FROM common_table_name
    * Syntax for a CTE with multiple queries:
        WITH 
        cte1 AS (query1),
        cte2 AS (query2),
        cte3 AS (query3),
        SELECT * FROM cte1
        UNION
        SELECT * FROM cte2
        UNION
        SELECT * FROM cte3

- Prepared Statements:
    -> A reusable MySQL statement that acts as a template & holds unspecified values as parameters.
    * Syntax: 
        + Creating:
            PREPARE prepared_name <query>
        + Executting:
            EXECUTE prepared_name (USING parameter_name)
            -> the param must be defined before the execution of the prepared, if a param is required.